version: "3"

services:
  db:
    build:
      context: .
      dockerfile: ./packages/db/Dockerfile
    restart: always
    env_file:
      - ./.env
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - app_network

  web:
    container_name: web
    build:
      context: .
      dockerfile: ./apps/web/Dockerfile
      args:
        NEXT_PUBLIC_API_BASE_URL: ${NEXT_PUBLIC_API_BASE_URL}
    restart: always
    env_file:
      - ./.env
    environment:
      - NEXT_PUBLIC_API_BASE_URL
    # This is quick dirty workaround - since it's just a technical test (local) it's okay
    # Idealy a better approach is to have a tiny reverse proxy using socat for e.g
    # that forwards localhost:3000 to server:3000 and run nextjs on 3001
    extra_hosts:
      - "localhost:172.28.0.10" # map 'localhost' -> server container IP
    networks:
      app_network:
        aliases:
          - web
    ports:
      - 80:3000
    depends_on:
      - server
  admin:
    container_name: admin
    build:
      context: .
      dockerfile: ./apps/admin/Dockerfile
    restart: always
    env_file:
      - ./.env
    environment:
      - VITE_API_BASE_URL
    ports:
      - 81:80
    networks:
      - app_network

    depends_on:
      - server
  server:
    container_name: server
    build:
      context: .
      dockerfile: ./apps/server/Dockerfile
    restart: always
    env_file:
      - ./.env
    ports:
      - 3000:3000
    depends_on:
      db:
        condition: service_healthy
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - PORT=3000
    networks:
      app_network:
        ipv4_address: 172.28.0.10 # static ip because api url is localhost too on web (127.0.0.1)

networks:
  app_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
volumes:
  postgres_data:
